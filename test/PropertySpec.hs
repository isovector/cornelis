{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications #-}

module PropertySpec where

import           Cornelis.Offsets
import           Cornelis.Vim
import           Data.Bool (bool)
import           Data.Containers.ListUtils (nubOrd)
import           Data.Maybe (mapMaybe)
import qualified Data.Text as T
import qualified Data.Vector as V
import           Neovim
import           Neovim.API.Text
import           Neovim.Test (Seconds(Seconds))
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck
import           Utils


spec :: Spec
spec = parallel $ do
  prop "fromBytes is an inverse of toBytes" $ do
    UnicodeString str <- arbitrary
    let len = length str
        t = T.pack str
    i <- suchThat arbitrary (\x -> 0 <= x && x <= len)
    let off = toZeroIndexed i
    pure
      $ counterexample (show str)
      $ counterexample (show i)
      $ fromBytes t (toBytes t off) === off

  prop "goto gets there" $ do
    n <- choose @Int (1, 50)
    strs <- vectorOf n $ listOf agdaChar
    row <- choose (1, length strs)
    let rowidx = row - 1
    col <- choose (0, max 0 $ length (strs !! rowidx) - 1)
    let pn = Pos (toOneIndexed row) (toOneIndexed col)
    pure
      $ counterexample (show strs)
      $ counterexample (show row)
      $ counterexample (show col)
      $ counterexample (show pn)
      $ counterexample (show $ strs !! rowidx)
      $ withVim (Seconds 1) $ \w b -> do
          buffer_set_lines b 0 (-1) False $ V.fromList $ fmap T.pack $ strs
          setWindowCursor w pn
          ObjectInt row' <- vim_call_function "line" $ V.fromList [ObjectString "."]
          ObjectInt col' <- vim_call_function "virtcol" $ V.fromList [ObjectString "."]
          liftIO $ Row row' `shouldBe` Row (fromIntegral row)
          -- virtcol is 1-based....
          liftIO $ Col (col' - 1) `shouldBe` Col (fromIntegral col)

  prop "replaceInterval does as it says" $ do
    str <- T.pack <$> listOf agdaChar
    rep <- T.pack <$> listOf agdaChar
    start <- choose (0, T.length str - 1)
    end <- choose (0, T.length str - start)
    let srow = toOneIndexed @Int 1
        scol = toOneIndexed start
        ecol = toOneIndexed (start + end)
        int = Interval (Pos srow scol) (Pos srow ecol)
        expected = T.take start str <> rep <> T.drop (start + end) str
    pure $
      withVim (Seconds 1) $ \_ b -> do
        buffer_set_lines b 0 (-1) False $ V.fromList $ pure str
        intervention b (mapMaybe simplify [Swap str expected]) $
          replaceInterval b int rep


agdaChar :: Gen Char
agdaChar = elements $ mconcat
  [ [' ' .. '~']
  , ['Â¡' .. 'Ã¿']
  , [ 'â†’', 'â†', 'âˆ§', 'âˆ¨', 'âˆŽ', 'âˆ˜', 'âŸ¨', 'âŸ©', 'â‰¡', 'â‰¢'
    , 'âˆ·', 'âˆ€', 'âˆƒ', 'â‰¤', 'â‰¥', 'â€²', 'âŠ¤', 'âŠ¥', 'â‰Ÿ', 'âŠ›'
    , 'Ã—', 'âŠ•', 'â–¹', 'âˆ¸', 'â¦ƒ', 'â¦„', 'â„•', 'â‡’', 'âˆˆ', 'â‚€'
    , 'â‚', 'â‚‚', 'â‚ƒ', 'â‚„', 'â‚…', 'â‚†', 'â‚‡', 'â‚ˆ', 'â‚‰', 'â°'
    , 'Â¹', 'Â²', 'Â³', 'â´', 'âµ', 'â¶', 'â·', 'â¸', 'â¹'
    , 'â‰ ', 'âˆ¼', 'â‰', 'â‰ˆ', 'â‰‰', 'â‰‹', 'âˆ»', 'â‰ƒ', 'â‰„', 'â‰‚'
    , 'â‰…', 'â‰‡', 'â‰Š', 'â‰¡', 'â‰¢', 'â‰£', 'â‰', 'â‰‘', 'â‰”', 'â‰•'
    , 'â‰—', 'â‰˜', 'â‰™', 'â‰š', 'â‰›', 'â‰œ', 'â‰', 'â‰ž', 'â‰Ÿ', 'â‰¤'
    , 'â‰¥', 'â‰°', 'â‰±', 'â‰°', 'â‰±', 'â‰®', 'â‰¯', 'â‰²', 'â‰³', 'â‹¦'
    , 'â‹§', 'â‰´', 'â‰µ', 'âŠ‚', 'âŠƒ', 'âŠ„', 'âŠ…', 'âŠ†', 'âŠ‡', 'âŠˆ'
    , 'âŠ‰', 'âŠ', 'âŠ', 'âŠ‘', 'âŠ’', 'â‹¢', 'â‹£', 'âˆ‰', 'âˆŒ', 'âˆ§'
    , 'âˆ¨', 'â‹€', 'â‹', 'âˆ©', 'âˆª', 'âŠŽ', 'âŠ', 'â‹‚', 'â‹ƒ', 'â¨„'
    , 'â¨ƒ', 'âŠ“', 'âŠ”', 'â¨…', 'â¨†', 'âŠ¢', 'âŠ¬', 'âŠ£', 'âŠ¨', 'âŠ­'
    , 'âŠ©', 'âŠ®', 'âŠ«', 'âŠ¯', 'âŠª', 'âˆ£', 'âˆ¤', 'âˆ¥', 'âˆ¦', 'âˆ€'
    , 'âˆƒ', 'âˆ„', 'âˆ…', 'âˆ', 'âŒœ', 'âŒˆ', 'âŒ', 'âŒ‰', 'âŒž', 'âŒŠ'
    , 'âŒŸ', 'âŒ‹', 'âˆŽ', 'Ã—', 'âˆ˜', 'âˆ˜', 'âˆ™', 'â‹†', 'âˆ”', 'âˆ¸'
    , 'âˆ·', 'âˆº', 'âˆ¹', 'âŠ¹', 'âˆ›', 'âˆœ', 'âˆ†', 'âˆž', 'â…‹', 'â¨Ÿ'
    , 'â¦‚', 'âŠ•', 'âŠ–', 'âŠ—', 'âŠ˜', 'âŠ™', 'âŠš', 'âŠ›', 'âŠœ', 'âŠ'
    , 'â¨', 'â¨‚', 'â¨€', 'âŸ', 'âŠž', 'âŠŸ', 'âŠ ', 'âŠ¡', 'â†', 'â†'
    , 'â‡', 'â‡', 'â†’', 'â†’', 'â‡’', 'â‡’', 'â†‘', 'â‡‘', 'â†“', 'â‡“'
    , 'â†•', 'â‡•', 'â†”', 'â†”', 'â‡”', 'â‡”', 'â†–', 'â‡–', 'â†—', 'â‡—'
    , 'â†˜', 'â‡˜', 'â†™', 'â‡™', 'â‡š', 'â‡‡', 'â‡†', 'â‡›', 'â‡‰', 'â‡¶'
    , 'â‡„', 'âŸ°', 'â‡ˆ', 'â‡…', 'âŸ±', 'â‡Š', 'â‡µ', 'âŸµ', 'âŸµ', 'â†œ'
    , 'âŸ¶', 'âŸ¶', 'â†', 'âŸ·', 'âŸ·', 'â†­', 'â†š', 'â†š', 'â‡', 'â†›'
    , 'â†›', 'â‡', 'â‡', 'â†®', 'â†®', 'â‡Ž', 'â‡Ž', 'â†¤', 'â†ž', 'â†¦'
    , 'â† ', 'â†¥', 'â†Ÿ', 'â†§', 'â†¡', 'â†¨', 'â†¢', 'â†£', 'âŠ¸', 'âŠ¸'
    , 'â†¯', 'â–£', 'â–¢', 'â–°', 'â–±', 'â—†', 'â—‡', 'â—ˆ', 'â—', 'â—‹'
    , 'â—Ž', 'â—Œ', 'â—¯', 'âœ¶', 'âœ´', 'âœ¹', 'ð”¸', 'ð”¹', 'â„‚', 'ð”»'
    , 'ð”¼', 'ð”½', 'ð”¾', 'â„', 'ð•€', 'ð•', 'ð•‚', 'ð•ƒ', 'ð•„', 'â„•'
    , 'ð•†', 'â„™', 'â„š', 'â„', 'ð•Š', 'ð•‹', 'ð•Œ', 'ð•', 'ð•Ž', 'ð•'
    , 'ð•', 'â„¤', 'â„¾', 'â„¿', 'â…€', 'ð•’', 'ð•“', 'ð•”', 'ð••', 'ð•–'
    , 'ð•—', 'ð•˜', 'ð•™', 'ð•š', 'ð•›', 'ð•œ', 'ð•', 'ð•ž', 'ð•Ÿ', 'ð• '
    , 'ð•¡', 'ð•¢', 'ð•£', 'ð•¤', 'ð•¥', 'ð•¦', 'ð•§', 'ð•¨', 'ð•©', 'ð•ª'
    , 'ð•«', 'â„½', 'â„¼', 'ðŸ˜', 'ðŸ™', 'ðŸš', 'ðŸ›', 'ðŸœ', 'ðŸ', 'ðŸž'
    , 'ðŸŸ', 'ðŸ ', 'ðŸ¡', 'ðŸŽ', 'ðŸ', 'ðŸ', 'ðŸ‘', 'ðŸ’', 'ðŸ“', 'ðŸ”'
    , 'ðŸ•', 'ðŸ–', 'ðŸ—', 'âŸ¦', 'âŸ§', 'âŸ¨', 'âŸ©', 'âŸª', 'âŸ«', 'â¦ƒ'
    , 'â¦„', 'âŸ…', 'âŸ†', 'âŸ…', 'âŸ†', 'â¦Š', 'â¦ˆ', 'â¦†', 'â€¢', 'â—¦'
    , 'â€£', 'â™­', 'â™¯', '\\', 'â€“', 'â€”', 'â€¼', 'â‡', 'â€½', 'â‰'
    , 'âœ‚', 'â€', 'â€¿', 'Î±', 'Î‘'
    , 'Î²', 'Î’', 'Î³', 'Î“', 'Î´', 'Î”', 'Îµ', 'Î•', 'Î¶', 'Î–'
    , 'Î·', 'Î—', 'Î¸', 'Î˜', 'Î¹', 'Î™', 'Îº', 'Îš', 'Î»', 'Î›'
    , 'Æ›', 'Î¼', 'Îœ', 'Î½', 'Î', 'Î¾', 'Îž', 'Ï', 'Î¡', 'Ïƒ'
    , 'Î£', 'Ï„', 'Î¤', 'Ï…', 'Î¥', 'Ï†', 'Î¦', 'Ï‡', 'Î§', 'Ïˆ'
    , 'Î¨', 'Ï‰', 'Î©', 'ð´', 'ðµ', 'ð¶', 'ð·', 'ð¸', 'ð¹', 'ðº'
    , 'ð»', 'ð¼', 'ð½', 'ð¾', 'ð¿', 'ð‘€', 'ð‘', 'ð‘‚', 'ð‘ƒ', 'ð‘„'
    , 'ð‘…', 'ð‘†', 'ð‘‡', 'ð‘ˆ', 'ð‘‰', 'ð‘Š', 'ð‘‹', 'ð‘Œ', 'ð‘', 'ð‘Ž'
    , 'ð‘', 'ð‘', 'ð‘‘', 'ð‘’', 'ð‘“', 'ð‘”', 'â„Ž', 'ð‘–', 'ð‘—', 'ð‘˜'
    , 'ð‘™', 'ð‘š', 'ð‘›', 'ð‘œ', 'ð‘', 'ð‘ž', 'ð‘Ÿ', 'ð‘ ', 'ð‘¡', 'ð‘¢'
    , 'ð‘£', 'ð‘¤', 'ð‘¥', 'ð‘¦', 'ð‘§', 'ð‘¨', 'ð‘©', 'ð‘ª', 'ð‘«', 'ð‘¬'
    , 'ð‘­', 'ð‘®', 'ð‘¯', 'ð‘°', 'ð‘±', 'ð‘²', 'ð‘³', 'ð‘´', 'ð‘µ', 'ð‘¶'
    , 'ð‘·', 'ð‘¸', 'ð‘¹', 'ð‘º', 'ð‘»', 'ð‘¼', 'ð‘½', 'ð‘¾', 'ð‘¿', 'ð’€'
    , 'ð’', 'ð’‚', 'ð’ƒ', 'ð’„', 'ð’…', 'ð’†', 'ð’‡', 'ð’ˆ', 'ð’‰', 'ð’Š'
    , 'ð’‹', 'ð’Œ', 'ð’', 'ð’Ž', 'ð’', 'ð’', 'ð’‘', 'ð’’', 'ð’“', 'ð’”'
    , 'ð’•', 'ð’–', 'ð’—', 'ð’˜', 'ð’™', 'ð’š', 'ð’›', 'ð’œ', 'â„¬', 'ð’ž'
    , 'ð’Ÿ', 'â„°', 'â„±', 'ð’¢', 'â„‹', 'â„', 'ð’¥', 'ð’¦', 'â„’', 'â„³'
    , 'ð’©', 'ð’ª', 'ð’«', 'ð’¬', 'â„›', 'ð’®', 'ð’¯', 'ð’°', 'ð’±', 'ð’²'
    , 'ð’³', 'ð’´', 'ð’µ', 'ð’¶', 'ð’·', 'ð’¸', 'ð’¹', 'â„¯', 'ð’»', 'â„Š'
    , 'ð’½', 'ð’¾', 'ð’¿', 'ð“€', 'ð“', 'ð“‚', 'ð“ƒ', 'â„´', 'ð“…', 'ð“†'
    , 'ð“‡', 'ð“ˆ', 'ð“‰', 'ð“Š', 'ð“‹', 'ð“Œ', 'ð“', 'ð“Ž', 'ð“', 'ð“'
    , 'ð“‘', 'ð“’', 'ð““', 'ð“”', 'ð“•', 'ð“–', 'ð“—', 'ð“˜', 'ð“™', 'ð“š'
    , 'ð“›', 'ð“œ', 'ð“', 'ð“ž', 'ð“Ÿ', 'ð“ ', 'ð“¡', 'ð“¢', 'ð“£'
    , 'ð“¤', 'ð“¥', 'ð“¦', 'ð“§', 'ð“¨', 'ð“©', 'ð“ª', 'ð“«', 'ð“¬', 'ð“­'
    , 'ð“®', 'ð“¯', 'ð“°', 'ð“±', 'ð“²', 'ð“³', 'ð“´', 'ð“µ', 'ð“¶', 'ð“·'
    , 'ð“¸', 'ð“¹', 'ð“º', 'ð“»', 'ð“¼', 'ð“½', 'ð“¾', 'ð“¿', 'ð”€', 'ð”'
    , 'ð”‚', 'ð”ƒ', 'ð”„', 'ð”…', 'â„­', 'ð”‡', 'ð”ˆ', 'ð”‰', 'ð”Š', 'â„Œ'
    , 'â„‘', 'ð”', 'ð”Ž', 'ð”', 'ð”', 'ð”‘', 'ð”’', 'ð”“', 'ð””', 'â„œ'
    , 'ð”–', 'ð”—', 'ð”˜', 'ð”™', 'ð”š', 'ð”›', 'ð”œ', 'â„¨', 'ð”ž', 'ð”Ÿ'
    , 'ð” ', 'ð”¡', 'ð”¢', 'ð”£', 'ð”¤', 'ð”¥', 'ð”¦', 'ð”§', 'ð”¨', 'ð”©'
    , 'ð”ª', 'ð”«', 'ð”¬', 'ð”­', 'ð”®', 'ð”¯', 'ð”°', 'ð”±', 'ð”²', 'ð”³'
    , 'ð”´', 'ð”µ', 'ð”¶', 'ð”·', 'â‚', 'â‚‘', 'â‚•', 'áµ¢', 'â±¼', 'â‚–'
    , 'â‚—', 'â‚˜', 'â‚™', 'â‚’', 'â‚š', 'áµ£', 'â‚›', 'â‚œ', 'áµ¤', 'áµ¥'
    , 'â‚“', 'áµ¦', 'áµ§', 'áµ¨', 'áµ©', 'áµª', 'áµƒ', 'áµ‡', 'á¶œ', 'áµˆ'
    , 'áµ‰', 'á¶ ', 'áµ', 'Ê°', 'â±', 'Ê²', 'áµ', 'Ë¡', 'áµ', 'â¿'
    , 'áµ’', 'áµ–', 'Ê³', 'Ë¢', 'áµ—', 'áµ˜', 'áµ›', 'Ê·', 'Ë£', 'Ê¸'
    , 'á¶»', 'á´¬', 'á´®', 'á´°', 'á´±', 'á´³', 'á´´', 'á´µ', 'á´¶', 'á´·'
    , 'á´¸', 'á´¹', 'á´º', 'á´¼', 'á´¾', 'á´¿', 'áµ€', 'áµ', 'â±½', 'áµ‚'
    , 'áµ', 'áµž', 'áµŸ', 'áµ‹', 'á¶¿', 'áµ ', 'áµ¡', ' ', 'Â¡', 'Â¢'
    , 'Â¦', 'Â°', 'Â¿', 'Âª', 'Âº'
    ]
  ]


simplify :: Eq a => Edit a -> Maybe (Edit a)
simplify x@(Swap b a) = bool Nothing (Just x) $ b /= a
simplify x = Just x

subsets :: Ord a => [a] -> [[a]]
subsets [] = [[]]
subsets zs@(x : xs) = nubOrd $ filter (/= zs) $ subsets xs ++ fmap (x :) (subsets xs)

newtype Row a = Row a deriving (Eq, Ord, Show)
newtype Col a = Col a deriving (Eq, Ord, Show)

